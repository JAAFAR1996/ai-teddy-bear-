# [AI-Generated by Amazon Q]: تم إضافة هذا الكود تلقائياً وفق دليل المشروع.
from collections import Counter
from datetime import datetime
from typing import Dict, List, Optional, Tuple

import librosa
import numpy as np


class SpeechFeatures:
    """استخراج خصائص الكلام"""

    @staticmethod
    def extract_pitch_features(audio_data: np.array, sr: int) -> Dict:
        """استخراج خصائص النبرة"""
        f0, voiced_flag, _ = librosa.pyin(
            audio_data, fmin=librosa.note_to_hz("C2"), fmax=librosa.note_to_hz("C7")
        )

        f0_clean = f0[~np.isnan(f0)]

        if len(f0_clean) == 0:
            return {
                "pitch_mean": 0,
                "pitch_std": 0,
                "pitch_min": 0,
                "pitch_max": 0,
                "pitch_range": 0,
            }

        return {
            "pitch_mean": np.mean(f0_clean),
            "pitch_std": np.std(f0_clean),
            "pitch_min": np.min(f0_clean),
            "pitch_max": np.max(f0_clean),
            "pitch_range": np.max(f0_clean) - np.min(f0_clean),
        }

    @staticmethod
    def extract_voice_quality_features(audio_data: np.array, sr: int) -> Dict:
        """استخراج خصائص جودة الصوت"""
        # Jitter (عدم انتظام النبرة)
        f0, voiced_flag, _ = librosa.pyin(
            audio_data, fmin=librosa.note_to_hz("C2"), fmax=librosa.note_to_hz("C7")
        )

        f0_clean = f0[~np.isnan(f0)]

        if len(f0_clean) > 1:
            jitter = np.mean(np.abs(np.diff(f0_clean))) / np.mean(f0_clean)
        else:
            jitter = 0

        # Shimmer (عدم انتظام الشدة)
        amplitude_envelope = np.abs(librosa.stft(audio_data))
        shimmer = np.std(amplitude_envelope) / np.mean(amplitude_envelope)

        return {"jitter": jitter, "shimmer": shimmer}


class SpeechDisorderDetector:
    """كاشف اضطرابات النطق المبكرة"""

    def __init__(self, model_path: Optional[str] = None):
        self.disorder_indicators = []
        self.alert_threshold = 0.3

        # قائمة الاضطرابات المحتملة
        self.disorder_types = {
            "stuttering": "تأتأة",
            "articulation": "اضطراب نطق الأصوات",
            "voice": "اضطراب الصوت",
            "fluency": "اضطراب الطلاقة",
        }

    def analyze_speech_patterns(self, audio_file: str) -> Dict:
        """تحليل أنماط النطق الشامل"""
        # تحميل الملف الصوتي
        audio_data, sr = librosa.load(audio_file, sr=None)

        # استخراج الخصائص
        features = {}

        # خصائص النبرة
        pitch_features = SpeechFeatures.extract_pitch_features(audio_data, sr)
        features.update(pitch_features)

        # خصائص جودة الصوت
        quality_features = SpeechFeatures.extract_voice_quality_features(audio_data, sr)
        features.update(quality_features)

        # كشف التأتأة
        stuttering_score = self._detect_stuttering(audio_data, sr)
        features["stuttering_score"] = stuttering_score

        # كشف التوقفات غير الطبيعية
        pause_analysis = self._analyze_pauses(audio_data, sr)
        features.update(pause_analysis)

        # تحليل معدل الكلام
        speech_rate = self._calculate_speech_rate(audio_data, sr)
        features["speech_rate"] = speech_rate

        # التقييم الشامل
        concerns = self._evaluate_concerns(features)

        # حفظ النتائج
        result = {
            "timestamp": datetime.now().isoformat(),
            "features": features,
            "concerns": concerns,
            "risk_level": self._calculate_risk_level(concerns),
        }

        self.disorder_indicators.append(result)

        return result

    def _detect_stuttering(self, audio_data: np.array, sr: int) -> float:
        """كشف التأتأة والتكرارات"""
        # تقسيم الصوت إلى مقاطع
        hop_length = int(0.01 * sr)  # 10ms
        frame_length = int(0.025 * sr)  # 25ms

        # حساب الطاقة لكل إطار
        energy = librosa.feature.rms(
            y=audio_data, frame_length=frame_length, hop_length=hop_length
        )[0]

        # كشف التكرارات السريعة
        energy_diff = np.diff(energy)
        rapid_changes = np.sum(np.abs(energy_diff) > np.std(energy_diff) * 2)

        # تطبيع النتيجة
        stuttering_score = min(1.0, rapid_changes / len(energy_diff))

        return stuttering_score

    def _analyze_pauses(self, audio_data: np.array, sr: int) -> Dict:
        """تحليل التوقفات في الكلام"""
        # كشف المقاطع الصامتة
        intervals = librosa.effects.split(audio_data, top_db=20)

        pauses = []
        for i in range(1, len(intervals)):
            pause_duration = (intervals[i][0] - intervals[i - 1][1]) / sr
            if pause_duration > 0.1:  # توقف أكثر من 100ms
                pauses.append(pause_duration)

        if pauses:
            return {
                "pause_count": len(pauses),
                "avg_pause_duration": np.mean(pauses),
                "max_pause_duration": np.max(pauses),
            }
        else:
            return {"pause_count": 0, "avg_pause_duration": 0, "max_pause_duration": 0}

    def _calculate_speech_rate(self, audio_data: np.array, sr: int) -> float:
        """حساب معدل الكلام (كلمة/دقيقة)"""
        # تقدير عدد المقاطع الصوتية
        onset_frames = librosa.onset.onset_detect(y=audio_data, sr=sr)
        syllable_count = len(onset_frames)
        duration_minutes = len(audio_data) / sr / 60

        # تقدير معدل الكلام (مقطع/دقيقة)
        # متوسط 1.5 مقطع لكل كلمة في العربية
        words_per_minute = (
            (syllable_count / 1.5) / duration_minutes if duration_minutes > 0 else 0
        )

        return words_per_minute

    def _evaluate_concerns(self, features: Dict) -> List[str]:
        """تقييم المخاوف بناءً على الخصائص"""
        concerns = []

        # تأتأة
        if features["stuttering_score"] > 0.3:
            concerns.append("احتمال وجود تأتأة")

        # بطء في الكلام
        if features["speech_rate"] < 80:
            concerns.append("معدل كلام بطيء")
        elif features["speech_rate"] > 200:
            concerns.append("معدل كلام سريع جداً")

        # مشاكل في جودة الصوت
        if features.get("jitter", 0) > 0.05:
            concerns.append("عدم انتظام في النبرة")

        if features.get("shimmer", 0) > 0.1:
            concerns.append("عدم انتظام في شدة الصوت")

        # توقفات غير طبيعية
        if features.get("pause_count", 0) > 10:
            concerns.append("توقفات متكررة في الكلام")

        if features.get("max_pause_duration", 0) > 2:
            concerns.append("توقفات طويلة غير طبيعية")

        return concerns

    def _calculate_risk_level(self, concerns: List[str]) -> str:
        """حساب مستوى الخطر"""
        concern_count = len(concerns)

        if concern_count == 0:
            return "منخفض"
        elif concern_count <= 2:
            return "متوسط"
        else:
            return "مرتفع"

    def should_alert_parents(self) -> Tuple[bool, List[Dict]]:
        """تحديد الحاجة لتنبيه الأهل"""
        if len(self.disorder_indicators) < 5:
            return False, []

        # تحليل آخر 10 تسجيلات
        recent_indicators = self.disorder_indicators[-10:]

        high_risk_count = sum(
            1 for ind in recent_indicators if ind["risk_level"] in ["متوسط", "مرتفع"]
        )

        # تنبيه إذا كان أكثر من 30% من التسجيلات تظهر مخاطر
        if high_risk_count >= 3:
            concerning_records = [ind for ind in recent_indicators if ind["concerns"]]
            return True, concerning_records

        return False, []

    def generate_report(self, child_id: str) -> Dict:
        """توليد تقرير شامل عن النطق"""
        if not self.disorder_indicators:
            return {"status": "no_data", "message": "لا توجد بيانات كافية للتحليل"}

        # تجميع المخاوف
        all_concerns = []
        for indicator in self.disorder_indicators:
            all_concerns.extend(indicator["concerns"])

        concern_counts = Counter(all_concerns)

        return {
            "status": "analyzed",
            "total_sessions": len(self.disorder_indicators),
            "common_concerns": dict(concern_counts.most_common(5)),
            "risk_assessment": self._assess_overall_risk(),
            "recommendations": self._generate_recommendations(concern_counts),
        }

    def _assess_overall_risk(self) -> str:
        """تقييم الخطر الإجمالي"""
        if not self.disorder_indicators:
            return "غير محدد"

        risk_levels = [ind["risk_level"] for ind in self.disorder_indicators]
        high_risk_count = sum(1 for level in risk_levels if level == "مرتفع")

        if high_risk_count > len(risk_levels) * 0.5:
            return "مرتفع"
        elif high_risk_count > len(risk_levels) * 0.2:
            return "متوسط"
        else:
            return "منخفض"

    def _generate_recommendations(self, concern_counts: Counter) -> List[str]:
        """توليد توصيات بناءً على التحليل"""
        recommendations = []

        for concern, count in concern_counts.items():
            if count >= 3:
                if "تأتأة" in concern:
                    recommendations.append(
                        "ينصح بممارسة تمارين التنفس العميق والتحدث ببطء"
                    )
                elif "معدل كلام" in concern:
                    recommendations.append(
                        "ممارسة القراءة بصوت عالٍ مع التركيز على الوتيرة المناسبة"
                    )
                elif "توقفات" in concern:
                    recommendations.append("تشجيع الطفل على التحدث بجمل قصيرة وبسيطة")

        if len(concern_counts) >= 3:
            recommendations.append("ننصح بشدة باستشارة أخصائي نطق للتقييم المهني")

        return recommendations
