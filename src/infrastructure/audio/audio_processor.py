from typing import Dict, List, Any, Optional

# [AI-Generated by Amazon Q]: تم إضافة هذا الكود تلقائياً وفق دليل المشروع.
import structlog
logger = structlog.get_logger(__name__)

import librosa
import soundfile as sf
import numpy as np
from pydub import AudioSegment
from pathlib import Path
import os

class AudioProcessor:
    """معالج الملفات الصوتية"""
    
    def __init__(self, uploads_dir: str = "uploads", outputs_dir: str = "outputs"):
        self.uploads_dir = Path(uploads_dir)
        self.outputs_dir = Path(outputs_dir)
        
        # إنشاء المجلدات
        self.uploads_dir.mkdir(exist_ok=True)
        self.outputs_dir.mkdir(exist_ok=True)
    
    def convert_format(self, input_file: str, output_format: str = "wav") -> str:
        """تحويل فورمات الملف الصوتي"""
        try:
            audio = AudioSegment.from_file(input_file)
            
            # تحديد مسار الإخراج
            input_path = Path(input_file)
            output_file = self.outputs_dir / f"{input_path.stem}.{output_format}"
            
            # تصدير بالفورمات الجديد
            audio.export(str(output_file), format=output_format)
            
            return str(output_file)
        except Exception as e:
    logger.error(f"Error: {e}")f"Format conversion error: {e}")
            return input_file
    
    def compress_audio(self, input_file: str, quality: str = "medium") -> str:
        """ضغط الملف الصوتي"""
        try:
            audio = AudioSegment.from_file(input_file)
            
            # إعدادات الضغط
            compression_settings = {
                "low": {"bitrate": "64k"},
                "medium": {"bitrate": "128k"},
                "high": {"bitrate": "192k"}
            }
            
            settings = compression_settings.get(quality, compression_settings["medium"])
            
            # تحديد مسار الإخراج
            input_path = Path(input_file)
            output_file = self.outputs_dir / f"{input_path.stem}_compressed.mp3"
            
            # تصدير مضغوط
            audio.export(str(output_file), format="mp3", bitrate=settings["bitrate"])
            
            return str(output_file)
        except Exception as e:
    logger.error(f"Error: {e}")f"Audio compression error: {e}")
            return input_file
    
    def clean_audio(self, input_file: str) -> str:
        """تنظيف وتحسين جودة الصوت"""
        try:
            # تحميل الملف
            audio_data, sr = librosa.load(input_file, sr=None)
            
            # تطبيع الصوت
            audio_data = librosa.util.normalize(audio_data)
            
            # إزالة الصمت من البداية والنهاية
            audio_data, _ = librosa.effects.trim(audio_data, top_db=20)
            
            # تحديد مسار الإخراج
            input_path = Path(input_file)
            output_file = self.outputs_dir / f"{input_path.stem}_cleaned.wav"
            
            # حفظ الملف المنظف
            sf.write(str(output_file), audio_data, sr)
            
            return str(output_file)
        except Exception as e:
    logger.error(f"Error: {e}")f"Audio cleaning error: {e}")
            return input_file
    
    def upload_audio(self, file_data: bytes, filename: str) -> str:
        """رفع ملف صوتي"""
        try:
            file_path = self.uploads_dir / filename
            
            with open(file_path, "wb") as f:
                f.write(file_data)
            
            return str(file_path)
        except Exception as e:
    logger.error(f"Error: {e}")f"Audio upload error: {e}")
            return ""
    
    def download_audio(self, filename: str) -> bytes:
        """تحميل ملف صوتي"""
        try:
            file_path = self.outputs_dir / filename
            
            if file_path.exists():
                with open(file_path, "rb") as f:
                    return f.read()
            
            return b""
        except Exception as e:
    logger.error(f"Error: {e}")f"Audio download error: {e}")
            return b""
    
    def get_audio_info(self, file_path: str) -> dict:
        """الحصول على معلومات الملف الصوتي"""
        try:
            audio_data, sr = librosa.load(file_path, sr=None)
            
            return {
                'duration': len(audio_data) / sr,
                'sample_rate': sr,
                'channels': 1 if len(audio_data.shape) == 1 else audio_data.shape[1],
                'file_size': os.path.getsize(file_path),
                'format': Path(file_path).suffix[1:]
            }
        except Exception as e:
    logger.error(f"Error: {e}")f"Audio info error: {e}")
            return {}

class MediaManager:
    """مدير الوسائط"""
    
    def __init__(self):
        self.audio_processor = AudioProcessor()
    
    def process_uploaded_audio(self, file_data: bytes, filename: str) -> dict:
        """معالجة ملف صوتي مرفوع"""
        # رفع الملف
        uploaded_path = self.audio_processor.upload_audio(file_data, filename)
        
        if not uploaded_path:
            return {'success': False, 'error': 'Upload failed'}
        
        # تنظيف الصوت
        cleaned_path = self.audio_processor.clean_audio(uploaded_path)
        
        # تحويل للفورمات المطلوب
        converted_path = self.audio_processor.convert_format(cleaned_path, "wav")
        
        # الحصول على معلومات الملف
        info = self.audio_processor.get_audio_info(converted_path)
        
        return {
            'success': True,
            'original_path': uploaded_path,
            'processed_path': converted_path,
            'info': info
        }
    
    def cleanup_old_files(self, days_old -> Any: int = 7) -> Any:
        """تنظيف الملفات القديمة"""
        import time
        current_time = time.time()
        
        for directory in [self.audio_processor.uploads_dir, self.audio_processor.outputs_dir]:
            for file_path in directory.glob("*"):
                if file_path.is_file():
                    file_age = current_time - file_path.stat().st_mtime
                    if file_age > (days_old * 24 * 3600):  # تحويل الأيام لثواني
                      except FileNotFoundError as e:
    logger.error(f"Error in operation: {e}", exc_info=True)FileNotFoundError as e:
    logger.error(f"Error in operation: {e}", exc_info=True)ileNotFoundError as e:
    logger.warning(f"Ignoring error: {e}")path.unlink()
                        except FileNotFoundError as e:
    logger.error(f"Error in operation: {e}", exc_info=True)FileNotFoundError as e:
    logger.error(f"Error in operation: {e}", exc_info=True)ileNotFoundError as e:
    logger.warning(f"Ignoring error: {e}")